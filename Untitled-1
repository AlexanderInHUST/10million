Data models:
    1. Network Model;
    2. Hierarchical Model;
    3. Relational Model;
    4. Object-oriented Model;
    5. Object-relational Model.
Relational Data Model:
    1. Data is modeled using relations;
    2. Each relation has a def called a relation schema;
        schema specifies attributes and data constraints;
        data constraints include domain constrains;
    3. Each row in a relation is called a tuple/record, it has one component for each attribute of relation;
    4. Domain - a set of atomic values;
    5. A relation is a set of tuples.
Integrity Constraints:
    1. A condition that restricts the data that can be stored in database instance;
    2. A legal relation instance is a relation that satisfies all specified ICs;
    3. Domain constraints / Key constraints / Foreign key constraints
Key Constraints:
    1. A superkey is a subset of attributes in a relation that uniquely identifies its tuples;
    2. A key is a superkey that satisfies that no proper subset of the key is a superkey;
    3. Key attribute values cannot be null;
    4. A relation could have multiple keys called candidate keys;
    5. One of the candidate keys is selected as the primary key;
    6. Foreign key value in referencing relation must either 
        (1) appear as primary key value;
        (2) be a null value;
    7. Foreign key constraints = referential integrity constraints;

Data models:
    1. Network Model;
    2. Hierarchical Model;
    3. Relational Model;
    4. Object-oriented Model;
    5. Object-relational Model.
Relational Data Model:
    1. Data is modeled using relations;
    2. Each relation has a def called a relation schema;
        schema specifies attributes and data constraints;
        data constraints include domain constrains;
    3. Each row in a relation is called a tuple/record, it has one component for each attribute of relation;
    4. Domain - a set of atomic values;
    5. A relation is a set of tuples.
Integrity Constraints:
    1. A condition that restricts the data that can be stored in database instance;
    2. A legal relation instance is a relation that satisfies all specified ICs;
    3. Domain constraints / Key constraints / Foreign key constraints
Key Constraints:
    1. A superkey is a subset of attributes in a relation that uniquely identifies its tuples;
    2. A key is a superkey that satisfies that no proper subset of the key is a superkey;
    3. Key attribute values cannot be null;
    4. A relation could have multiple keys called candidate keys;
    5. One of the candidate keys is selected as the primary key;
    6. Foreign key value in referencing relation must either 
        (1) appear as primary key value;
        (2) be a null value;
    7. Foreign key constraints = referential integrity constraints;
SQL:
    1. SQL is a domain-specific language / declarative language;
    2. Statement-Level Interface / Call-Level Interface
    3. Data Definition Language DDL : create / delete / modify schemas
       Data Manipulation Language DML : ... data
Detail SQL:
    1. Create / Drop Table;
    2. Data Types:
        boolean,
        integer, numeric, real,
        char(50), varchar(50), text,
        data, time, timestamp
    3. NULL value
        Result of a comparison op is unknown
        Result of an arithmetic op is null
        Ues IS NULL to check NULL
        a IS DISTINCT FROM b eq. <> and both not null
    4. Constraints Types
        Not-null / Unique / Primary key / Foreign key / General Constraints
        * check (name is not null)
        * unique (city, state)
        * primary key (sid, cid)
        * foreign key (cid) references Courses (cid)
            (must be primary key or unique)
        * check (year > 2010 or rating > 8.0)
    5. insert into Students values (.., ..);
       insert into Students (name, studentID) values (.., ..);
    6. delete from Students where ...;
    7. update Students set balance = balance + 1 where ...;
    8. begin; ...; ...; commit; / rollback;
        Atomicity / Consistency / Isolation / Durability
    9. foreign key (sid) references Students on delete / update 
        NO ACTION / RESTRICT / CASCADE / SET DEFAULT / SET NULL
    10. alter table Students alter / drop / add column ...;
    11. select cname from ... where cname like '___%e';
        _ matches any single character;
        % matches any seq of 0 or more characters;
    12. union / intersect / except
    13. natural join / inner join / left outer join / full outer join
    14. exists / in / any (some) / all / unique / min / max / avg;
    15. order by / limit / view / group by / having
    16. i. Compute the cross-product of the tables in from-list;
        ii. Select the tuples in the cross-product that evaluate to true for the where-condition;
        iii. Partition the selected tuples into groups using the groupby-list;
        iv. Select the groups that evaluate to true for the having-condition condition;
        v. For each selected group, generate an output tuple by selecting/computing the attributes/expressions that appear in the select-list;
        vi. Remove any duplicate output tuples;
        vii. Sort the output tuples based on the orderby-list;
        viii. Remove the appropriate output tuples based on the limit-specification;
    17. with .. as .. (CTEs)
    18. case when ... then when ... then ... else ... end as XXX
        case exp. where value1 then ... when value2 then ... else ... end as XXX
Statement-Level Interface:
    1. EmbeddedSQL
        SQL constructs are SQL statements
        SQL statements are known at compile time
    2. DynamicSQL
        SQL constructs are directives for preparing/executing SQL statements
        SQL statements are stored in string variables
        SQL statements may not be known at compile time
    3. Host language & SQL constructs -> Embedded SQL Preprocessor -> Host language & Function calls -> Compiler -> Program
Call-Level Interface:
    1. Vendor-independent API for database access;
    2. Unlike SLI,programs are written entirely in host language;
    3. Uses string variables to construct SQL statements (similar to dynamic SQL)
ANSI SQL Isolation Levels
    1. The isolation level for a transaction affects what the transaction will read;
    2. ANSI SQL defines four isolation levels;
        • Read Uncommitted (weakest isolation level)
        • Read Committed
        • Repeatable Read
        • Serializable (strongest isolation level)
    3. Choice of isolation level affects correctness vs performance tradeoff
    4. In many DBMSs,the default isolation level is Read Commited
    5. Configure using set transaction isolation level statement
Serializable Transaction Executions
    1. Consider a set of transactions S = {T1,···,Tn}
    2. An execution of S is a serial execution if the execution of the transactions in S are not interleaved
    3. An execution of S is serializable if it is equivalent to some serial execution of S
    4. Serializable executions guarantee correctness of transaction executionsANSI SQL Isolation Levels
    1. The isolation level for a transaction affects what the transaction will read;
    2. ANSI SQL defines four isolation levels;
        • Read Uncommitted (weakest isolation level)
        • Read Committed
        • Repeatable Read
        • Serializable (strongest isolation level)
    3. Choice of isolation level affects correctness vs performance tradeoff
    4. In many DBMSs,the default isolation level is Read Commited
    5. Configure using set transaction isolation level statement
Serializable Transaction Executions
    1. Consider a set of transactions S = {T1,···,Tn}
    2. An execution of S is a serial execution if the execution of the transactions in S are not interleaved
    3. An execution of S is serializable if it is equivalent to some serial execution of S
    4. Serializable executions guarantee correctness of transaction executions
Functions:
    1.  DROP FUNCTION hello();
        CREATE OR REPLACE FUNCTION gst(val NUMERIC) RETURNS NUMERIC AS $$
        DECLARE gst1 NUMERIC;
        BEGIN
        SELECT g.gst/100 INTO gst1 FROM gst g; RETURN val * (1 + gst1);
        RAISE NOTICE 'hello';
        END; $$
        LANGUAGE PLPGSQL;
    2.  IF condition
            THEN ...
            ELSIF condition
            THEN ...
            ELSE ... END